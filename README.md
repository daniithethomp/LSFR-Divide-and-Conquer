# LSFR Divide and Conquer
## Overview
This project demonstrates a cryptanalytic attack on a simple stream cipher that combines the outputs of three LFSRs using a non-linear combining function. Instead of brute-forcing all possible states ($2^{31}$ combinations), the attack exploits correlation properties to recover the initial states efficiently.

## Attack Methodology 
The attack works in three phases:

1. **LSFR2 Recovery** ($2^{11}$ = 2,048 attempts)
  - Test all possible 11-bit states
  - Find the state that correlates ~75% with the target keystream
2. **LSFR3 Recovery** ($2^{13}$ = 8,192 attempts)
  - Test all possible 13-bit state
  - Find the state that correlates ~75% with the target keystream
3. **LSFR1 Recovery** ($2^7$ = 128 attempts)
  - With known LSFR2 and LSFR3 states, tests all 7-bit states
  - Finds the state that produces 100% agreement with the target

**Total complexity:** ~10,368 attempts instead of 2,147,483,648 (brute force)

## Components
`LSFR.java`: Linear Feedback Shift Register implementation with configurable taps
`DivideAndConquer.java`: Main attack implementation using correlation analysis
`Streamfile.txt`: Target keystream generated by a simple stream cipher composing of 3 LSFRs, which are clocked in step, together with a simple combining function $f(x_1,x_2,x_3)$

### Combining Function
|$x=x_1x_2x_3$|f(x)||$x=x_1x_2x_3$|f(x)|
|-|-|-|-|-|
|000|0||100|0|
|001|1||101|0|
|010|0||110|1|
|011|1||111|1|

## The Registers
**LSFR1**: 7-bit register, taps at positions \[0, 6\]

**LSFR2**: 11-bit register, taps at positions \[10, 1\]

**LSFR3**: 13-bit register, taps at positions \[0, 2, 3, 12\]

## Usage
```bash
javac lab1/*.java
java lab1.DivideAndConquer
```
